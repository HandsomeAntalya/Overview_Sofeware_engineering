# OSE WEEK 1 -4

<aside>
ğŸ’¡ OSE Content from week 1 - 4

</aside>

key words: 

Software development; Models; Waterfall; Agile; Spiral; V-model; DevOps

# Introduction and Process

---

Grounding of the SE Discipline and Historic View

Introduction to Software Engineering 

Waterfall life Cycle Model 

# What covered

---

- Software development
- Software crisis
- Introduction to Software Engineering
- Software development life cycle
- Waterfall life Cycle Model
- Agile model
- V-Model
- Spiral model

# Other notes

---

[OSE - Agile week 2](https://www.notion.so/OSE-Agile-week-2-78fb24d8bc4a42f3844fb1d453e75626)

[Requirement engineering ](https://www.notion.so/Requirement-engineering-34e29888595349c6a173b0d2c30e31ce) 

[Object Oriented Design](https://www.notion.so/Object-Oriented-Design-ff5f48df7a78491198163791875585d0) 

---

# Main contents

## Software development

Software development is the process of **designing**, **building**, **testing**, and **maintaining software** products or applications. It involves a systematic approach to developing software, which typically includes the following steps:

1. **Requirements gathering**: This involves understanding the needs and goals of the software product, and gathering requirements from stakeholders such as users, clients, and business analysts.
2. **Design**: This involves creating a detailed plan for the software product, including the architecture, user interface, data model, and other technical aspects.
3. **Implementation**: This involves writing the code for the software product, using programming languages and tools such as compilers, editors, and integrated development environments (IDEs).
4. **Testing**: This involves verifying that the software product meets the requirements and works as expected. Testing can include various techniques such as unit testing, integration testing, and acceptance testing.
5. **Deployment(éƒ¨ç½²ï¼›è°ƒåŠ¨)**: This involves releasing the software product to users, either on-premises or in the cloud.
6. **Maintenance**: This involves fixing bugs, making updates, and providing ongoing support for the software product to ensure it continues to meet the needs of users.

Software development can be done by individuals or teams, and can involve various methodologies such as Agile, Waterfall, and DevOps. It is a complex and dynamic field that requires a deep understanding of programming languages, software design patterns, and best practices.

## Software crisis

Background:

"software crisis" refers to a period in the **1960s and 1970s** when software development projects were struggling to deliver software that met the requirements of users, was delivered on time, and within **budget**. The term was coined by Edsger W. Dijkstra in 1970, who argued that the problem was caused by the increasing complexity of software systems, and the lack of suitable programming tools and methodologies to manage that complexity.

The software crisis led to the development of new software engineering practices and techniques, including structured programming, modular design, and software testing. These practices helped to improve the quality and reliability of software, and led to the development of new programming languages, such as Pascal, Ada, and C.

**Software crisis today:**

Today, while the software crisis of the past has largely been addressed through advancements in software engineering practices, new challenges continue to arise as software systems become more complex and interconnected. These challenges include issues related to **security**, **scalability**, and the **management** of large and distributed software systems.

**Challenges we face today**: 

1. Security: With the rise of **cyber threats** and the increasing use of software in critical systems such as healthcare, finance, and transportation, security has become a major concern. Software developers must design and implement security measures to protect against threats such as hacking, data breaches, and malware. å®‰å…¨æ€§å—åˆ°å¨èƒ
2. Complexity: Modern software systems can be **extremely complex**, with multiple components and dependencies that are difficult to manage. As software systems become more complex, it becomes more challenging to maintain and update them, leading to issues such as system downtime, performance problems, and bugs. æ“ä½œè¿‡äºå¤æ‚
3. Interoperability(**äº’ç”¨æ€§**): Software systems today often need to work with other systems, and ensuring that different systems can communicate and work together can be a challenge. This is especially true in industries such as healthcare and finance, where different systems must be able to exchange data and information securely and accurately. å’Œå…¶ä»–ç³»ç»Ÿçš„å…¼å®¹æ€§
4. Scalability(**å¯æ‰©å±•æ€§**): Software systems must be able to handle increasing amounts of data and traffic as they grow, which can be a challenge for developers. Ensuring that software systems can scale up or down as needed without sacrificing performance or reliability is a key challenge.  å¤„ç†æ—¥ç›Šå¢é•¿çš„æ•°æ®å’Œæµé‡
5. User experience: With the increasing focus on user-centric design, software developers must ensure that their products are easy to use, intuitive, and meet the needs of users. This can be a challenge when designing software for complex systems or specialized industries. ç”¨æˆ·ä½“éªŒ
6. Time to market is shorter than ever: the need to release products to market **quickly** in order to stay competitive. The increasing pace of innovation and the demand for new and better software products has led to shorter development cycles and tighter deadlines.

# Why do software project fail?

1. Poor Requirements Gathering: A software project may fail if the requirements for the software product are not clearly defined, or if they are poorly communicated to the development team. This can lead to misaligned expectations and poor design decisions that can affect the quality and functionality of the software. éœ€æ±‚æ”¶é›†ä¸è¯¦å°½/ over-ambitious requirements/ Unnecessary/ poor requirements. 
2. Lack of Project Management: Without a strong project management approach, software projects can easily fall behind schedule, go over budget, or fail to meet user needs. Effective project management includes setting clear goals and objectives, defining project scope, managing timelines, and ensuring that team members are working effectively and efficiently.ï¼ˆè¿›ç¨‹ç®¡ç†ä¸åˆ°ä½ï¼‰
3. Inadequate Testing: Testing is a critical component of software development, as it helps to identify and correct defects and ensure that the software meets the requirements of users. If testing is not performed adequately, defects may go unnoticed and software quality may suffer. ï¼ˆæµ‹è¯•ä¸å¤Ÿï¼‰
4. Technical Complexity: As software systems become more complex, it can be challenging for development teams to keep up with the latest technologies and techniques. This can lead to design flaws, security vulnerabilities, and other issues that can affect software quality and functionality.ï¼ˆè½¯ä»¶ç³»ç»Ÿè¿‡äºå¤æ‚ï¼‰
5. Communication Issues: Communication is critical to the success of software development projects. Without effective communication between team members, stakeholders, and users, misunderstandings and misaligned expectations can arise, leading to project delays, rework, or failure.ï¼ˆæ²Ÿé€šä¸æˆåŠŸï¼‰
6. Lack of User Involvement: If users are not involved in the software development process, it can be challenging to ensure that the software meets their needs and expectations. This can lead to low user adoption rates and ultimately, project failure. ï¼ˆç”¨æˆ·å‚ä¸è¿‡å°‘ï¼‰
7. Poor Resource Management: Inadequate resources, including personnel, tools, and funding, can also contribute to software project failure. Without the necessary resources, development teams may struggle to meet project goals and objectives, leading to delays, quality issues, and other problems.ï¼ˆèµ„æºç®¡ç†ä¸åˆ°ä½ï¼‰
8. Other factors like bad developers/ over budget/ contract management/ End-user training/ Operational management 

## Software Engineering discipline ğŸŒŸğŸŒŸğŸŒŸ

Engineering: cost-effective solutions to practical problems by applying scientific knowledge to building things for people.  

Software engineering is a discipline that involves the **design**, **development**, **testing**, **deployment**, and **maintenance** of software products. It is a structured and systematic approach to software development that aims to ensure that software products are reliable, efficient, and maintainable.

Software engineering involves a range of activities, including requirements gathering, analysis, and design, as well as coding, testing, and deployment. It also involves managing the software development process, including project planning, scheduling, and budgeting.

Some of the **key principles** of software engineering include:

1. Quality: Software engineering places a strong emphasis on software quality, with a focus on ensuring that software products are reliable, efficient, and maintainable.
2. Process: Software engineering is a structured and systematic approach to software development, with a focus on following a defined process to ensure that software products are developed and delivered efficiently and effectively.
3. Management: Software engineering involves managing the software development process, including project planning, scheduling, and budgeting.
4. Teamwork: Software engineering is a collaborative discipline that involves working in teams to design, develop, and maintain software products.
5. Communication: Effective communication is critical to the success of software engineering projects, with a focus on clear and concise communication between team members, stakeholders, and users.
6. Continuous Improvement: Software engineering is an iterative process that involves continuous improvement, with a focus on identifying and correcting defects, improving software quality, and meeting the evolving needs of users and stakeholders.

Overall, software engineering is a discipline that provides a structured and systematic approach to software development, with a focus on ensuring that software products are reliable, efficient, and maintainable. It involves a range of activities and principles, including quality, process, management, teamwork, communication, and continuous improvement.

## Collaboration Tools and techniques

UML Designs(modeling): Diagramming to reach a consensus on design;

GitHub: sharing of documents for effective collaboration; integrating individual project;

Kanban: Task allocation and progress monitoring 

Test-driven development: Stop other people breaking your code ;

## Software development : Life Cycle Process ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ

![https://bigwater.consulting/wp-content/uploads/2019/04/SDLC_BWC.png](https://bigwater.consulting/wp-content/uploads/2019/04/SDLC_BWC.png)

1. Planning (Requirements Analysis): This involves understanding the needs and requirements of the software product, including its functionality, performance, and usability.
2. Analysis and design (high level and detailed): This involves analyzing the requirements and designing a software solution that meets those requirements. This may involve creating a high-level design that outlines the system architecture, or a detailed design that specifies the software components, interfaces, and data structures.
3.  Development / Coding and implementation: This involves writing the code that implements the software design, using programming languages and development tools.
4. Testing: This involves testing the software to ensure that it meets the requirements and functions as intended. This may involve manual testing, automated testing, or a combination of both.
5. Deployment: This involves deploying the software to the production environment, including installing the software, configuring it, and verifying that it is working as expected.
6. Maintenance: This involves maintaining the software over time, including fixing defects, updating functionality, and addressing security issues.
7. Documentation: This involves creating documentation that describes the software product, including its features, functionality, and usage instructions.

## Software development life cycle (SDLC)examples:

## Waterfall model:

In this model, the development process flows sequentially through stages such as requirements gathering, design, implementation, testing, deployment, and maintenance. Each stage must be completed before moving to the next one.

![https://static.javatpoint.com/tutorial/jira/images/jira-waterfall-model.png](https://static.javatpoint.com/tutorial/jira/images/jira-waterfall-model.png)

å…³é”®è¯ï¼šä¾åºè¿›è¡Œ;

å¼€å‘è¿‡ç¨‹æ˜¯é€šè¿‡è®¾è®¡ä¸€ç³»åˆ—é˜¶æ®µé¡ºåºå±•å¼€çš„ï¼Œä»ç³»ç»Ÿ[éœ€æ±‚åˆ†æ](https://baike.baidu.com/item/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/2012709?fromModule=lemma_inlink)
å¼€å§‹ç›´åˆ°äº§å“å‘å¸ƒå’Œç»´æŠ¤ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½ä¼šäº§ç”Ÿå¾ªç¯åé¦ˆï¼Œå› æ­¤ï¼Œå¦‚æœæœ‰ä¿¡æ¯æœªè¢«è¦†ç›–æˆ–è€…å‘ç°äº†é—®é¢˜ï¼Œé‚£ä¹ˆæœ€å¥½ â€œè¿”å›â€ä¸Šä¸€ä¸ªé˜¶æ®µå¹¶è¿›è¡Œé€‚å½“çš„ä¿®æ”¹ï¼Œé¡¹ç›®å¼€å‘è¿›ç¨‹ä»ä¸€ä¸ªé˜¶æ®µâ€œæµåŠ¨â€åˆ°ä¸‹ä¸€ä¸ªé˜¶æ®µï¼Œè¿™ä¹Ÿæ˜¯ç€‘å¸ƒæ¨¡å‹åç§°çš„ç”±æ¥ã€‚åŒ…æ‹¬[è½¯ä»¶å·¥ç¨‹](https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279?fromModule=lemma_inlink)å¼€å‘ã€ä¼ä¸šé¡¹ç›®å¼€å‘ã€äº§å“ç”Ÿäº§ä»¥åŠå¸‚åœºé”€å”®ç­‰æ„é€ ç€‘å¸ƒæ¨¡å‹ã€‚

**è¯¾å ‚ç¬”è®°ï¼š**

è½¯ä»¶å·¥ç¨‹çš„åŸºçŸ³ï¼›

æŒ‰ç…§é¡ºåºè¿›è¡Œè®¾è®¡é€‚åˆæ”¿åºœçš„ä¸€äº›é¡¹ç›®ï¼›

ä½†å¹¶ä¸æ˜¯æ‰€æœ‰çš„ç¨‹åºéƒ½é€‚åˆè¿™ä¸ªæ¨¡å‹ï¼›

The Waterfall model is a **linear** and **sequential** software development process that flows through a series of phases such as requirements gathering, design, implementation, testing, deployment, and maintenance. Each phase must be completed before moving to the next one, with a focus on planning and documentation.

In the Waterfall model, the requirements gathering phase is typically the first phase of the development process. During this phase, the requirements for the software product are gathered and documented in detail. This includes identifying the functional and non-functional requirements of the software, as well as any constraints or limitations that may apply.

The Waterfall model is best suited for software development projects where the requirements are well-defined and unlikely to change significantly over time. It works well when the software product is relatively simple, with clear and unambiguous requirements. It is also well-suited for projects where a detailed project plan and schedule are important, as it emphasizes planning and documentation.  é€‚åˆä¸€å¼€å§‹éœ€æ±‚å°±è¢«è¯¦ç»†å‘ŠçŸ¥çš„/ç®€å•çš„ç¨‹åº/æ¸…æ™°ä¸æ¨¡ç³Šçš„éœ€æ±‚

However, the Waterfall model can be less suitable for projects where the requirements are not well-defined or are likely to change over time. It can also be challenging for projects that require a high degree of collaboration or flexibility, as the linear and sequential nature of the model can limit the ability to make changes or adjustments as the project progresses.

ä¸é€‚åˆï¼šä¸€ç›´æ”¹å˜çš„éœ€æ±‚ï¼›éœ€è¦é«˜åº¦åä½œæˆ–çµæ´»æ€§çš„é¡¹ç›®ï¼›

### Advantages of Waterfall Development:

1. Predictability: Waterfall development is known for its predictability, as each stage of the development process is completed before moving onto the next. This makes it easier to plan and allocate resources. Easy to classify and prioritize tasks.
2. Clear milestones: Waterfall development has clear milestones, which makes it easier to track progress and manage the project.
3. Documentation: Waterfall development prioritizes documentation, which can be helpful for teams that need to maintain and update the software product over time.
4. Well-suited for well-defined projects: Waterfall development is well-suited for projects with well-defined requirements and a need for a predictable outcome.
5. Simple to use and understand 
6. Every phase has a defined result and process review;
7. Development stages go one by one;

### Drawbacks of Waterfall Development:

1. Limited flexibility: Waterfall development is less flexible than Agile development, which can make it difficult to adapt to changing requirements or circumstances.
2. Limited collaboration: Waterfall development is less collaborative than Agile development, which can lead to a lack of communication and collaboration between team members.
3. Risk of project failure: Waterfall development can be risky, as problems or issues may not be discovered until later stages of the development process.
4. Late feedback: Waterfall development may not provide feedback until the testing phase, which can be too late to make significant changes.
5. Miss complexity due to interdependence of decisions;
6. Not suited for long-tern project where requirements will change; ä¸é€‚åˆè¾ƒé•¿æœŸçš„é¡¹ç›®

## Agile model:

In this model, development occurs in short iterations or sprints, with each iteration focusing on a specific set of requirements or features. Agile development emphasizes collaboration, flexibility, and rapid feedback.

![https://www.nvisia.com/hubfs/agile-methodology-chicago.png](https://www.nvisia.com/hubfs/agile-methodology-chicago.png)

æ•æ·å¼€å‘ä»¥ç”¨æˆ·çš„éœ€æ±‚è¿›åŒ–ä¸ºæ ¸å¿ƒï¼Œé‡‡ç”¨è¿­ä»£ã€å¾ªåºæ¸è¿›çš„æ–¹æ³•è¿›è¡Œ[è½¯ä»¶å¼€å‘](https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/3448966?fromModule=lemma_inlink)ã€‚åœ¨æ•æ·å¼€å‘ä¸­ï¼Œè½¯ä»¶é¡¹ç›®åœ¨æ„å»ºåˆæœŸè¢«åˆ‡åˆ†æˆå¤šä¸ªå­é¡¹ç›®ï¼Œå„ä¸ªå­é¡¹ç›®çš„æˆæœéƒ½ç»è¿‡æµ‹è¯•ï¼Œå…·å¤‡å¯è§†ã€å¯é›†æˆå’Œå¯è¿è¡Œä½¿ç”¨çš„ç‰¹å¾ã€‚æ¢è¨€ä¹‹ï¼Œå°±æ˜¯æŠŠä¸€ä¸ªå¤§é¡¹ç›®åˆ†ä¸ºå¤šä¸ªç›¸äº’è”ç³»ï¼Œä½†ä¹Ÿå¯ç‹¬ç«‹è¿è¡Œçš„å°é¡¹ç›®ï¼Œå¹¶åˆ†åˆ«å®Œæˆï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­è½¯ä»¶ä¸€ç›´å¤„äº[å¯ä½¿ç”¨çŠ¶æ€](https://baike.baidu.com/item/%E5%8F%AF%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81/53651177?fromModule=lemma_inlink)ã€‚

CollabNet One æœ€è¿‘çš„ä¸€ä»½æŠ¥å‘Šæ˜¾ç¤ºï¼Œ**97% çš„ç»„ç»‡ç°åœ¨éƒ½åœ¨å®è·µæ•æ·å¼€å‘æ–¹æ³•**ã€‚æ•æ·å—æ¬¢è¿çš„ç§˜è¯€åœ¨äºèƒ½å¤Ÿæ›´å¿«åœ°å°†è½¯ä»¶å¼€å‘è§£å†³æ–¹æ¡ˆæ¨å‘å¸‚åœºã€‚ä»æå€¡æ—©æœŸäº¤ä»˜ã€æŒç»­å¼€å‘ã€é€‚åº”æ€§è§„åˆ’ä»¥åŠçµæ´»åº”å¯¹å˜åŒ–ï¼Œæ•æ·è½¯ä»¶å¼€å‘ä½¿è·¨èŒèƒ½å›¢é˜Ÿèƒ½å¤Ÿå¼€å‘å’Œè¿­ä»£ï¼Œä»è€Œæ›´è½»æ¾åœ°ç”Ÿäº§æœ€å°å¯è¡Œäº§å“ (MVP)ã€‚ä¸æ–­æ”¶é›†å’Œå®æ–½åé¦ˆã€‚è¿™ä¸€åŠ¨æ€è¿‡ç¨‹å…è®¸å›¢é˜Ÿä¸ºå®ç°ä¸€ä¸ªç›®æ ‡è€Œå…±åŒåŠªåŠ›ã€‚

**æ•æ·ä¸å…¶è¯´æ˜¯ä¸€ç§æ–¹æ³•è®ºï¼Œä¸å¦‚è¯´æ˜¯ä¸€å¥—ä»·å€¼è§‚ã€ç†æƒ³å’Œç›®æ ‡**

The Agile model is an **iterative** and **incremental software development** (è¿­ä»£å’Œå¢é‡çš„è½¯ä»¶å¼€å‘æ–¹æ³•) approach that emphasizes collaboration, flexibility, and rapid feedback. The Agile model is based on the **[Agile Manifesto](https://www.notion.so/Agile-Manifesto-7a3c1afc778048db98092c6e5a7bd44b)**, a set of values and principles for software development that prioritize individuals and interactions, working software, customer collaboration, and response to change.

In the Agile model, development occurs in short iterations or sprints, with each iteration focusing on a specific set of requirements or features. The development team works closely with the customer or product owner to prioritize requirements and ensure that the software product meets their needs.

The Agile model emphasizes continuous **integration** and **delivery**, with a focus on delivering working software at the end of each iteration. The development team and customer or product owner collaborate closely throughout the development process, with a focus on rapid feedback and continuous improvement.

keywords of Agile:  flexibility, collaboration, and rapid feedback. 

ä¸€äº›ç‰¹ç‚¹ Here are some key features of Agile development:

1. Iterative and incremental: Agile development is based on short iterations or sprints, with each iteration focused on delivering a working software product. This iterative approach allows development teams to respond to feedback and changes quickly.
2. Collaboration: Agile development emphasizes collaboration between development teams, customers, and stakeholders. This collaboration is essential to ensure that the software product meets the needs of its users.
3. Flexibility: Agile development prioritizes flexibility and adaptability, allowing development teams to respond to changing requirements and circumstances quickly.
4. Continuous integration and delivery: Agile development emphasizes continuous integration and delivery, with a focus on delivering working software at the end of each iteration.
5. Customer-centric: Agile development is focused on delivering software products that meet the needs of customers and stakeholders. This customer-centric approach ensures that the software product is useful and valuable.
6. Rapid feedback: Agile development emphasizes rapid feedback, allowing development teams to respond to issues and changes quickly.
7. Self-organizing teams: Agile development encourages self-organizing teams, allowing team members to take ownership of their work and make decisions about how they work.

Drawbacks:

1. Lack of predictability: Agile development is focused on flexibility and adaptability, which can make it difficult to predict the final outcome of a project. This lack of predictability can be challenging for project managers and stakeholders who need to plan and allocate resources.(ç¼ºå°‘å¯é¢„æµ‹æ€§ï¼‰
2. Limited documentation: Agile development prioritizes working software over documentation, which can lead to a lack of comprehensive documentation. This can be challenging for teams that need to maintain and update the software product over time.ï¼ˆæœ‰é™çš„æ–‡ä»¶è®°å½•ï¼‰
3. Requires strong team collaboration: Agile development requires a high degree of collaboration and communication between team members. This can be challenging for teams that are not used to working together or have members who are geographically dispersed.ï¼ˆéœ€è¦å¾ˆå¼ºçš„å°ç»„åˆä½œï¼‰
4. Potential for scope creep: Agile development encourages flexibility and adaptability, which can lead to scope creep if requirements and priorities are not clearly defined and managed.ï¼ˆèŒƒå›´è •å˜çš„å¯èƒ½æ€§ï¼‰
5. May not be suitable for all projects: Agile development is best suited for projects with changing or undefined requirements, where a high degree of flexibility and rapid feedback is required. It may not be the best approach for projects with well-defined requirements and a need for a predictable outcome. ï¼ˆå¯èƒ½ä¸é€‚åˆæ‰€æœ‰é¡¹ç›®ï¼‰

Agile is well-suited for projects where **customer feedback and collaboration** are key priorities. It emphasizes delivering working software in smaller iterations or sprints, allowing for frequent customer feedback and adjustments to the project based on that feedback. However, Agile may not be as effective for projects with a high degree of uncertainty or where risk management is a key priority (so we can consider spiral model).

## Spiral model:

In this model, the development process is iterative and includes phases such as planning, risk analysis, development, and evaluation. Each iteration builds on the previous one, with the goal of improving the software product over time.

![https://www.sovereignconsult.com/wp-content/uploads/2021/09/Spiral-Model-Methodology.png](https://www.sovereignconsult.com/wp-content/uploads/2021/09/Spiral-Model-Methodology.png)

The Spiral model is a software development process model that combines elements of both Waterfall and Agile development. It is an iterative model that emphasizes risk management and focuses on delivering a high-quality software product

èºæ—‹æ¨¡å‹æ˜¯ä¸€ç§æ¼”åŒ–[è½¯ä»¶å¼€å‘è¿‡ç¨‹](https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/3758917?fromModule=lemma_inlink)æ¨¡å‹ï¼Œå®ƒå…¼é¡¾äº†[å¿«é€ŸåŸå‹](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B/7432267?fromModule=lemma_inlink)çš„[è¿­ä»£](https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3/8415523?fromModule=lemma_inlink)çš„ç‰¹å¾ä»¥åŠ[ç€‘å¸ƒæ¨¡å‹](https://baike.baidu.com/item/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/9817778?fromModule=lemma_inlink)çš„ç³»ç»ŸåŒ–ä¸ä¸¥æ ¼ç›‘æ§ã€‚èºæ—‹æ¨¡å‹æœ€å¤§çš„ç‰¹ç‚¹åœ¨äºå¼•å…¥äº†å…¶ä»–æ¨¡å‹ä¸å…·å¤‡çš„é£é™©åˆ†æï¼Œä½¿è½¯ä»¶åœ¨æ— æ³•æ’é™¤é‡å¤§é£é™©æ—¶æœ‰æœºä¼šåœæ­¢ï¼Œä»¥å‡å°æŸå¤±ã€‚åŒæ—¶ï¼Œåœ¨æ¯ä¸ªè¿­ä»£é˜¶æ®µæ„å»ºåŸå‹æ˜¯èºæ—‹æ¨¡å‹ç”¨ä»¥å‡å°é£é™©çš„é€”å¾„ã€‚èºæ—‹æ¨¡å‹æ›´é€‚åˆå¤§å‹çš„æ˜‚è´µçš„ç³»ç»Ÿçº§çš„è½¯ä»¶åº”ç”¨ã€‚Â [1]

1988å¹´ï¼Œå·´åˆ©Â·ç»å§†(Barry Boehm)æ­£å¼å‘è¡¨äº†[è½¯ä»¶](https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6?fromModule=lemma_inlink)ç³»ç»Ÿå¼€å‘çš„â€œèºæ—‹æ¨¡å‹â€ï¼Œå®ƒå°†[ç€‘å¸ƒæ¨¡å‹](https://baike.baidu.com/item/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/9817778?fromModule=lemma_inlink)å’Œprototyingç»“åˆèµ·æ¥ï¼Œå¼ºè°ƒäº†å…¶ä»–æ¨¡å‹æ‰€å¿½è§†çš„é£é™©åˆ†æï¼Œç‰¹åˆ«é€‚åˆäºå¤§å‹å¤æ‚çš„ç³»ç»Ÿã€‚

The Spiral model is characterized by the following phases:

1. Planning: The first phase involves gathering requirements, defining project objectives, and identifying potential risks. The project is also planned out in terms of resources, timelines, and budget.
2. Risk analysis: In this phase, potential risks are identified and analyzed, and strategies are developed to mitigate them. The project is also evaluated in terms of its feasibility, and adjustments are made as necessary.
3. Engineering: The third phase involves developing the software product based on the requirements and objectives identified in the planning phase. The software is developed in smaller iterations or sprints, with each iteration building on the previous one.
4. Evaluation: In this phase, the software product is tested and evaluated to ensure that it meets the project objectives and requirements. Any issues or problems are identified and addressed in the subsequent iteration.

The Spiral model is designed to be flexible and adaptable, allowing development teams to adjust the project based on feedback and changing requirements. It emphasizes risk management, ensuring that potential issues are identified and addressed early in the development process.

Advantages:

1. Risk management: The Spiral model places a strong emphasis on risk management, allowing development teams to identify and mitigate potential issues early in the development process. é£é™©ç®¡ç†
2. Flexibility: The Spiral model is more flexible than the Waterfall model, allowing development teams to adjust the project based on feedback and changing requirements. 
3. Incremental delivery: The Spiral model uses incremental delivery, allowing development teams to deliver a working software product in smaller iterations or sprints. å¢é‡äº¤ä»˜
4. Customer feedback: The Spiral model allows for customer feedback throughout the development process, ensuring that the software product meets the customer's requirements.

Disadvantages:

1. Complexity: The Spiral model is more complex than other development models, requiring a high level of expertise and experience to implement effectively.
2. Cost and time: The Spiral model can be more expensive and time-consuming than other development models due to its iterative nature and risk management focus.
3. Documentation: The Spiral model requires extensive documentation, which can be time-consuming and may detract from development time.
4. Team coordination: The Spiral model requires strong team coordination and communication, which can be challenging for larger development teams or teams that are geographically dispersed.

Overall, the Spiral model is a **flexible** and **adaptable** development model that prioritizes risk management and customer feedback. While it may be more complex and time-consuming than other development models, it is well-suited for projects with a high degree of uncertainty or for teams that value risk management and customer feedback.

Spiral model is well-suited for projects with **a high degree of uncertainty** or where **risk management is a key priority**. It allows development teams to identify and mitigate potential risks early in the development process, and it is more flexible than the Waterfall model. However, it can be more complex and time-consuming than other models, and it requires a high level of expertise and experience to implement effectively.

## DevOps model (extra information):

In this model, development and operations teams work closely together throughout the software development life cycle, with a focus on continuous integration, delivery, and deployment. DevOps emphasizes **collaboration**, automation, and rapid feedback.

![https://miro.medium.com/max/1400/0*n57zykBMdOdmUg7C.png](https://miro.medium.com/max/1400/0*n57zykBMdOdmUg7C.png)

DevOps is a software development approach that combines the development (Dev) and operations (Ops) teams to work together throughout the entire software development lifecycle. The goal of DevOps is to increase collaboration and communication between development and operations teams to enable faster, more reliable software releases.

The DevOps model includes the following key practices:

1. Continuous Integration æŒç»­é›†æˆ (CI): The practice of continuously merging code changes into a shared repository and verifying that the new code does not break the existing codebase.
2. Continuous Delivery æŒç»­äº¤ä»˜ (CD): The practice of automating the software deployment process to ensure that software releases can be quickly and reliably deployed to production.
3. Infrastructure as Code (IaC) åŸºç¡€è®¾æ–½å³ä»£ç : The practice of managing infrastructure through code, enabling faster and more reliable provisioning and configuration of infrastructure resources.
4. Continuous Monitoring (CM) æŒç»­ç›‘æ§: The practice of continuously monitoring the software system in production to identify issues and make improvements.

One of the key advantages of the DevOps model is that it enables organizations to deliver software faster and with higher quality. By combining development and operations teams, the DevOps model can reduce the time and effort required to manage and deploy software, and improve the overall quality of the software by ensuring that it is continuously tested and monitored.

Advantages of DevOps:

1. Faster time to market: DevOps helps organizations to deliver software faster and more frequently, which can give them a competitive advantage in the market.
2. Improved collaboration: By combining development and operations teams, DevOps can improve communication and collaboration between teams, resulting in better software quality and reliability.
3. Increased efficiency: Automation and tooling in DevOps can help to reduce manual effort and increase efficiency in software development and deployment.
4. Better quality: DevOps promotes continuous testing and monitoring, which can improve software quality and reliability.
5. Improved customer satisfaction: With faster and more frequent releases, DevOps can help organizations to better meet customer needs and expectations.

Drawbacks of DevOps:

1. Cultural changes: Adopting DevOps often requires significant cultural changes within an organization, which can be challenging and time-consuming.
2. Investment in automation and tooling: DevOps requires investment in automation and tooling, which can be expensive and require significant resources.
3. Security risks: DevOps can increase security risks if proper security measures are not implemented throughout the software development lifecycle.
4. Complexity: DevOps can be complex, especially for larger organizations, and may require significant planning and coordination to implement effectively.
5. Learning curve: Adopting DevOps may require new skills and training for development and operations teams, which can be a challenge for some organizations.

## V-model:

In this model, the development process flows through phases such as requirements gathering, design, implementation, testing, and acceptance. Each phase has a corresponding testing phase, with testing occurring in parallel to development.

![https://media.geeksforgeeks.org/wp-content/uploads/V-Model.png](https://media.geeksforgeeks.org/wp-content/uploads/V-Model.png)

å¼ºè°ƒæµ‹è¯•çš„ä¸€ä¸ªæ¨¡å‹ï¼›ç±»ä¼¼waterfall, ä½†æ˜¯æ›´å¤šçš„æµ‹è¯•

The V-model is a software development model that is similar to the Waterfall model but places a greater emphasis on **testing** throughout the development process. The name "V-model" comes from the shape of the model, which looks like a "V" when graphically represented.

The V-model includes the following stages, each of which has a corresponding testing stage:

1. Requirements gathering: In this stage, the project requirements are gathered and documented.
2. System design: In this stage, the high-level design of the software system is developed, including system architecture and interfaces.
3. Unit design: In this stage, the detailed design of each software component or module is developed.
4. Implementation: In this stage, the software code is written and tested at the unit level.
5. Integration: In this stage, the software components are integrated and tested as a complete system.
6. System testing: In this stage, the complete software system is tested to ensure that it meets the requirements and performs as expected.
7. Acceptance testing: In this stage, the software system is tested by the customer or end-user to ensure that it meets their needs.

One of the key advantages of the V-model is that it places a strong emphasis on testing throughout the development process, which can help to identify and correct defects early in the development process. This can help to reduce the overall cost and time required for testing and debugging.

However, one potential disadvantage of the V-model is that it can be less flexible than other development models, such as Agile. The V-model assumes that the project requirements are well-defined and that the development process can proceed in a linear fashion. This may not be suitable for projects where the requirements are less well-defined or where frequent customer feedback is needed.

Overall, the V-model can be a useful development model for projects where testing is a key priority, and the project requirements are well-defined. However, it may not be as effective for projects with high levels of uncertainty or where customer feedback is needed throughout the development process.

Advantages of V-model:

1. Emphasizes testing: One of the main advantages of the V-model is that it places a strong emphasis on testing throughout the development process, which can help to identify and correct defects early in the development process.
2. Clear deliverables: The V-model provides clear deliverables at each stage of the development process, which can help to ensure that the project is on track and progressing as expected.
3. Easy to understand: The V-model is easy to understand and implement, making it a popular choice for many software development projects.
4. Risk management: The V-model includes risk management at each stage of the development process, which can help to identify and mitigate potential risks early in the development process.

Drawbacks of V-model:

1. Rigid and inflexible: The V-model can be less flexible than other development models, such as Agile, and may not be suitable for projects with high levels of uncertainty or where frequent customer feedback is needed. ä¸çµæ´»
2. High documentation: The V-model requires a significant amount of documentation, which can be time-consuming and may not be necessary for all projects.
3. May not be suitable for small projects: The V-model may be too complex and time-consuming for small software development projects. å¯¹äºå°é¡¹ç›®ä¸é€‚åˆ
4. Can be difficult to make changes: Once the development process has begun, it can be difficult to make changes to the project requirements or design, which can be a drawback for projects where the requirements may change over time. æ”¹å˜å›°éš¾ 

Overall, the V-model can be a useful development model for projects where **testing** is a key priority and the project **requirements are well-defined.** However, it may not be as effective for projects with high levels of uncertainty or where customer feedback is needed throughout the development process.

## Some test:(è¿™äº›é—®é¢˜æ˜¯chatGPT ç”Ÿæˆçš„æœ‰äº›è¿˜æ˜¯ä¸å¤ªå‡†ç¡®)

1. Which software development model is best suited for projects with well-defined requirements and a fixed scope?
a. Agile
b. Waterfall
c. Spiral
d. DevOps
2. Which software development model is most suited for large and complex projects with multiple phases?
a. Agile
b. Waterfall
c. Spiral
d. DevOps
3. Which software development model emphasizes continuous testing and feedback throughout the development process?
a. Agile
b. Waterfall
c. Spiral
d. V-model
4. Which software development model emphasizes risk management and continual improvement throughout the development process?
a. Agile
b. Waterfall
c. Spiral
d. DevOps
5. Which software development model is most likely to be used in projects where requirements are not well-defined or may change frequently?
a. Agile
b. Waterfall
c. Spiral
d. V-model
6. Which software development model emphasizes a flexible and collaborative approach, with a focus on delivering working software frequently?
a. Waterfall
b. V-model
c. Spiral
d. Agile
7. Which software development model places a strong emphasis on automation, continuous integration, and continuous delivery?
a. DevOps
b. Agile
c. Waterfall
d. V-model
8. Which software development model is best suited for projects where the requirements are not well-defined or may change frequently?
a. Waterfall
b. V-model
c. Spiral
d. Agile
9. Which software development model emphasizes risk management and continual improvement throughout the development process?
a. Waterfall
b. V-model
c. Spiral
10. Which software development model is characterized by a series of iterations or sprints, with a focus on frequent releases and customer collaboration?
a. Waterfall
b. V-model
c. Agile
d. Spiral
11. Which software development model involves the development and testing of small, incremental changes that are integrated and tested continuously?
a. Waterfall
b. V-model
c. Agile
d. Spiral
12. Which software development model involves a series of stages, with each stage building on the previous stage and culminating in the delivery of a final product?
a. Agile
b. DevOps
c. Waterfall
d. V-model
13. Which software development model emphasizes the importance of documentation and formal review processes?
a. Waterfall
b. V-model
c. Agile
d. Spiral
14. Which software development model is designed to address the challenges of coordinating development and operations teams?
a. DevOps
b. Agile
c. Waterfall
d. V-model
15. Which software development model is most suitable for projects with well-defined requirements and a fixed scope?
a. Agile
b. DevOps
c. Waterfall
d. V-model

Answer:

1. b
2. c
3. a
4. c
5. a
6. d
7. a
8. d
9. c 
10. c
11. c
12. c
13. a
14. a
15. c

ï¼ˆè¿™äº›æ˜¯çº¿ä¸Šæ‰¾æ¥çš„æµ‹è¯•ï¼‰

1. **Who should review the detailed design before it is developed?**

 As many stakeholders as possible.Â 

1. **A programmer would be a useful person to employ in which stage?**

Implementation 

1. **Which of these is the correct order of the SDLC?**

**Planning, Analysis, Design, Implementation, Maintenance**

1. **What happens in the design phase?**

**Planning the solution, look and feel of the software interface**

1. **What happens in the Analysis Stage?**

**Look at the existing system and find areasÂ to improve**

æ˜“é”™ç‚¹ï¼š

Agile also emphasizes risk management and continual improvement throughout the development process, but it does so in a different way than the V-model. Agile approaches risk management by breaking the project into smaller iterations and focusing on delivering working software frequently, which allows for early identification and mitigation of risks. Continuous improvement is achieved through regular retrospectives and feedback loops.

In contrast, the V-model focuses on identifying and managing risks during each stage of the development process and places a strong emphasis on testing and verification activities to reduce risks. The V-model is a sequential development process that emphasizes testing at each stage of development but does not necessarily prioritize continuous testing and feedback throughout the entire development process.

## Conclusion

â€¢ The Waterfall model is mostly used on smaller projects where the requirements are clear and thereâ€™s no need to change them quickly. Itâ€™s a well-structured approach. The stages are well-defined and easy to understand for all.

â€¢ Agile and Lean models suit small- and medium-sized projects with rapid changes required. The customer is involved during each stage. Limited planning is required to get started with a project. Businesses save both money and time as each iteration is discussed closely between the customer and the development team.

â€¢ The Spiral model combines the elements of the Prototyping and Waterfall models. The Spiral methodology is suitable for large, complex, and expensive projects. Its benefits are risk-management and stage-by-stage development.

â€¢ The DevOps is a newbie model. It allows for continuous software development, faster resolution of problems, happier, more productive teams, and higher employee engagement.

[Requirement engineering ](https://www.notion.so/Requirement-engineering-34e29888595349c6a173b0d2c30e31ce)

[Object Oriented Design](https://www.notion.so/Object-Oriented-Design-ff5f48df7a78491198163791875585d0)